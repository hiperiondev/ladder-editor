<!--    
    Copyright 2025 Emiliano Gonzalez (egonzalez . hiperion @ gmail . com))
    Project Site: https://github.com/hiperiondev/ladder-editor
    
    The MIT License (MIT)
    
    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:
    
    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ladder PLC Editor</title>
    <style>
        /* CSS Variables for consistent and maintainable sizing across the editor */
        :root {
            --cell-size: 60px;      /* Size of each grid cell */
            --label-width: 40px;    /* Width of row and column labels */
            --controls-height: 60px;/* Height of the network control area */
        }

        /* Media query for responsive design on small screens (max-width: 600px) */
        @media (max-width: 600px) {
            :root {
                --cell-size: 40px;      /* Smaller cell size for compact screens */
                --label-width: 30px;    /* Reduced label width */
                --controls-height: 50px;/* Reduced controls height */
            }
            /* Hides table headers in symbol values table for better mobile display */
            #symbolValues th {
                display: none;
            }
        }

        /* General styling for the body of the page */
        body {
            font-family: Arial, sans-serif; /* Sets a clean, readable font */
            background-color: #f0f0f0;      /* Light gray background */
            margin: 20px;                   /* Adds padding around the content */
            overflow-x: auto;               /* Allows horizontal scrolling if needed */
        }

        /* Styles the controls section containing action buttons */
        #controls {
            margin-bottom: 20px; /* Space below the controls for separation */
        }

        /* Container for all network diagrams, arranged vertically */
        #networks-container {
            display: flex;
            flex-direction: column;
            gap: 20px; /* Space between individual networks */
        }

        /* Wrapper for each network, including its controls and table */
        .network-wrapper {
            position: relative; /* Allows absolute positioning of child elements */
            display: block;
            margin-bottom: 20px; /* Space below each network */
        }

        /* Styles the grid table representing a ladder logic network */
        .network-table {
            border-collapse: collapse;                       /* Removes gaps between cells */
            background-color: #fff;                          /* White background for the grid */
            box-shadow: 0 0 10px rgba(0,0,0,0.1);            /* Subtle shadow for depth */
            margin-left: var(--label-width);                 /* Offset for row labels */
            margin-top: calc(var(--controls-height) + 20px); /* Space for controls */
            margin-bottom: 40px;                             /* Extra space below the table */
            border: 1px solid #ddd;                          /* Light border around the table */
        }

        /* Styles individual cells in the network table */
        .network-table td {
            width: var(--cell-size);  /* Fixed width from CSS variable */
            height: var(--cell-size); /* Fixed height from CSS variable */
            border: 1px solid #ddd;   /* Light border for cell outlines */
            padding: 0;               /* Removes default padding */
            text-align: center;       /* Centers content horizontally */
            vertical-align: middle;   /* Centers content vertically */
            cursor: pointer;          /* Indicates cells are clickable */
            position: relative;       /* For positioning SVGs or bars */
            overflow: visible;        /* Allows SVGs to extend beyond cell */
            box-sizing: border-box;   /* Includes border in size calculations */
            background-color: #fff;   /* White background for cells */
        }

        /* Hover effect for cells to indicate interactivity */
        .network-table td:hover {
            background-color: #f5f5f5; /* Light gray on hover */
        }

        /* Ensures SVGs within cells fit properly */
        .network-table td svg {
            width: 100%;              /* Fills the cell width */
            height: 100%;             /* Fills the cell height */
            display: block;
            margin: 0 auto;           /* Centers the SVG */
            object-fit: contain;      /* Maintains SVG aspect ratio */
            preserveAspectRatio: meet;/* Preserves SVG proportions */
        }

        /* Styles for SVGs spanning multiple cells (e.g., timers) */
        .multi-cell-svg {
            position: absolute;      /* Positions SVG over multiple rows */
            top: 0;
            left: 0;
            width: var(--cell-size); /* Matches cell width */
        }

        /* Common styles for row and column labels */
        .row-label, .col-label {
            font-size: 14px;        /* Readable font size */
            font-weight: bold;      /* Bold for emphasis */
            color: #333;            /* Dark gray color */
            position: absolute;     /* Absolute positioning relative to wrapper */
            pointer-events: none;   /* Prevents interference with clicks */
        }

        /* Specific styles for row labels (left of the grid) */
        .row-label {
            width: var(--label-width);   /* Fixed width from CSS variable */
            text-align: right;           /* Right-aligned text */
            left: 0;
            padding-right: 6px;          /* Space between label and grid */
            top: calc(var(--controls-height) + 20px + var(--row-index) * var(--cell-size) + (var(--cell-size) / 2)); /* Positions based on row index */
            transform: translateY(-50%); /* Vertically centers the label */
        }

        /* Specific styles for column labels (above the grid) */
        .col-label {
            width: var(--cell-size); /* Matches cell width */
            text-align: center;      /* Centers the label text */
            top: calc(var(--controls-height) + 20px - 3px - 14px); /* Positions above grid */
            left: calc(var(--label-width) + var(--col-index) * var(--cell-size)); /* Positions based on column index */
        }

        /* Styles the symbol values table container */
        #symbolValues {
            margin-top: 20px;           /* Space above the table */
            background-color: #fff;     /* White background */
            padding: 15px;              /* Internal padding */
            border-radius: 8px;         /* Rounded corners */
            box-shadow: 0 0 5px rgba(0,0,0,0.1); /* Subtle shadow */
        }

        /* Styles the table inside the symbol values container */
        #symbolValues table {
            width: 100%;               /* Full width of the container */
            border-collapse: collapse; /* Removes gaps between cells */
            margin-top: 10px;          /* Space above the table */
        }

        /* Styles table headers and cells in symbol values table */
        #symbolValues th, #symbolValues td {
            border: 1px solid #ddd; /* Light border for cells */
            padding: 8px;           /* Internal padding */
            text-align: left;       /* Left-aligned text */
        }

        /* Styles table headers specifically */
        #symbolValues th {
            background-color: #0288d1; /* Blue background */
            color: white;              /* White text */
        }

        /* Alternating row colors for readability */
        #symbolValues tr:nth-child(even) td.data {
            background-color: #fffde7; /* Light yellow for even rows */
        }
        #symbolValues tr:nth-child(odd) td.data {
            background-color: #f5f5f5; /* Light gray for odd rows */
        }

        /* Specific column styling in symbol values table */
        #symbolValues td.network-id {
            background-color: #e0f7fa; /* Light cyan for network ID */
        }
        #symbolValues td.symbol {
            background-color: #e6ffe6; /* Light green for symbol names */
        }

        /* Styles for the symbol and data type context menus */
        #symbolMenu, #dataTypeMenu {
            position: absolute;     /* Positions at click location */
            background-color: #fff; /* White background */
            border: 1px solid #ccc; /* Light border */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Shadow for depth */
            z-index: 1000;          /* Ensures menu appears above other elements */
            padding: 5px;           /* Internal padding */
            display: none;          /* Hidden by default */
            min-width: 150px;       /* Minimum width for readability */
        }

        /* Styles for items within the menus */
        .menu-item {
            padding: 5px 10px; /* Padding for clickable area */
            cursor: pointer;   /* Indicates interactivity */
        }
        .menu-item:hover {
            background-color: #e0e0e0; /* Gray hover effect */
        }

        /* Styles for data entry sections in the data type menu */
        .value-entry {
            margin-bottom: 10px; /* Space between entries */
        }
        .value-label {
            font-weight: bold; /* Bold labels */
            margin-right: 5px; /* Space before input */
        }
        .value-pair {
            display: flex;      /* Flexbox for alignment */
            align-items: center;/* Vertically centers items */
            margin: 5px 0;      /* Vertical spacing */
        }
        .value-pair select, .value-pair input, .value-pair span {
            margin-right: 5px; /* Space between elements */
            font-size: 12px;   /* Smaller font for compactness */
        }

        /* General button styling */
        button {
            padding: 5px 10px;    /* Padding for size */
            margin-right: 5px;    /* Space between buttons */
            background-color: #4CAF50; /* Green background */
            color: white;         /* White text */
            border: none;         /* No border */
            cursor: pointer;      /* Indicates clickability */
        }
        button:hover {
            background-color: #45a049; /* Darker green on hover */
        }

        /* Specific styling for delete buttons */
        .delete-button {
            background-color: #ff0000; /* Red background */
        }
        .delete-button:hover {
            background-color: #cc0000; /* Darker red on hover */
        }

        /* Styling for input fields (e.g., resize inputs) */
        input {
            padding: 5px;      /* Internal padding */
            margin-right: 10px;/* Space after input */
            width: 60px;       /* Fixed width */
        }

        /* Controls section for each network (resize, delete) */
        .network-controls {
            position: absolute; /* Positions above the table */
            top: 0;
            left: 0;
            display: flex;      /* Flexbox for horizontal layout */
            align-items: center;/* Vertically centers items */
            padding: 5px 0;     /* Vertical padding */
            z-index: 10;        /* Ensures visibility over table */
        }

        /* Label displaying the network number */
        .network-label {
            position: absolute;      /* Positioned above controls */
            top: -20px;              /* Offset above the wrapper */
            left: 0;
            font-weight: bold;       /* Bold text */
            width: 150px;            /* Fixed width */
            white-space: nowrap;     /* Prevents wrapping */
            overflow: hidden;        /* Hides overflow */
            text-overflow: ellipsis; /* Adds ellipsis for long text */
        }

        /* Styles for vertical bars connecting ladder rungs */
        .vertical-bar {
            position: absolute; /* Positioned over the grid */
            z-index: 100;       /* Ensures visibility */
        }

        @media (max-width: 600px) {
            .row-label, .col-label {
                font-size: 12px; /* Smaller font size */
            }
            .row-label {
                left: 0;
                padding-right: 6px; /* Adjusted padding */
            }
            .col-label {
                top: calc(var(--controls-height) + 20px - 3px - 12px); /* Adjusted position */
            }
            input {
                width: 50px; /* Smaller input width */
            }
            .network-label {
                width: 120px; /* Reduced width */
            }
            #symbolValues table {
                font-size: 12px; /* Smaller font */
            }
            #symbolValues th, #symbolValues td {
                padding: 5px; /* Reduced padding */
            }
            /* Converts table to block layout for mobile */
            #symbolValues table, #symbolValues thead, #symbolValues tbody, #symbolValues th, #symbolValues td, #symbolValues tr {
                display: block;
            }
            #symbolValues thead {
                display: none; /* Hides headers */
            }
            #symbolValues tr {
                margin-bottom: 15px; /* Space between rows */
            }
            #symbolValues td {
                border: none;       /* Removes borders */
                position: relative; /* For pseudo-element positioning */
                padding-left: 50%;  /* Space for labels */
                text-align: left;   /* Left-aligned text */
            }
            /* Adds labels before each cell using data-label attribute */
            #symbolValues td::before {
                content: attr(data-label);
                position: absolute;
                left: 6px;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: bold;
            }
            #symbolValues td.data {
                word-wrap: break-word; /* Allows text wrapping */
            }
        }

        /* Animation for blinking effect to highlight elements */
        .blinking {
            animation: backgroundBlink 1s infinite; /* Blinks background */
        }
        .blinking svg [stroke] {
            animation: strokeBlink 1s infinite; /* Blinks SVG stroke */
        }
        .blinking svg text {
            animation: fillBlink 1s infinite; /* Blinks SVG text */
        }
        @keyframes backgroundBlink {
            0% { background-color: #fff; }
            50% { background-color: lightgray; } /* Light red at peak */
            100% { background-color: #fff; }
        }
        @keyframes strokeBlink {
            0% { stroke: gray; }
            50% { stroke: black; }
            100% { stroke: gray; }
        }
        @keyframes fillBlink {
            0% { fill: gray; }
            50% { fill: black; }
            100% { fill: gray; }
        }
        tr.blinking td {
            animation: rowBlink 1s infinite; /* Blinks entire row */
        }
        @keyframes rowBlink {
            0% { background-color: #fff; }
            50% { background-color: lightgray; }
            100% { background-color: #fff; }
        }

        /* Highlights active cells (e.g., during WebSocket updates) */
        td.active {
            background-color: yellow; /* Yellow background */
        }
    </style>
</head>
<body>
    <!-- Controls for managing networks and actions -->
    <div id="controls">
        <!-- Button to add a new network -->
        <button onclick="addNetwork()">Add Network</button>
        <!-- Button to save networks (via WebSocket or file) -->
        <button onclick="saveNetworks()">Save</button>
        <!-- Hidden file input for loading networks from JSON -->
        <input type="file" id="loadFile" accept=".json" style="display: none;" onchange="loadNetworks(event)">
        <!-- Button to trigger loading (file or server) -->
        <button onclick="initiateLoad()">Load</button>
        <!-- Button to undo the last action -->
        <button onclick="undo()">Undo</button>
        <!-- Button to redo an undone action -->
        <button onclick="redo()">Redo</button>
        <!-- WebSocket connection status indicator -->
        <div id="ws-indicator" style="display: inline-block; width: 20px; height: 20px; border-radius: 50%; background-color: red; margin-left: 10px;"></div>
    </div>

    <!-- Container where all network diagrams are dynamically added -->
    <div id="networks-container"></div>

    <!-- Context menu for selecting ladder logic symbols -->
    <div id="symbolMenu"></div>

    <!-- Context menu for setting data types and values -->
    <div id="dataTypeMenu"></div>

    <!-- Table displaying all symbols and their associated data -->
    <div id="symbolValues"></div>

    <script>
        // List of supported data types for symbol data entries
        const dataTypes = [
            "NONE", "M", "Q", "I", "Cd", "Cr", "Td", "Tr", "IW", "QW", "C", "T",
            "D", "CSTR", "REAL", "MS", "10MS", "100MS",
            "SEC", "MIN", "K"
        ];

        // Definitions of ladder logic symbols with their properties
        const symbols = {
            "NOP": { // No Operation symbol
                cells: 1,              // Occupies 1 cell
                dataEntries: [],       // No data required
                svg: `<svg viewBox="0 0 60 60"><rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2"/><text x="30" y="25" font-size="12" text-anchor="middle" fill="gray">NOP</text></svg>`,
                pins: [{ left: false, right: false }] // No connections
            },
            "CONN": { // Connection line symbol
                cells: 1,
                dataEntries: [],
                svg: `<svg viewBox="0 0 60 60"><line x1="0" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2"/></svg>`,
                pins: [{ left: true, right: true }] // Connects left and right
            },
            "NEG": { // Negation symbol
                cells: 1,
                dataEntries: [],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">NEG</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "NO": { // Normally Open contact
                cells: 1,
                dataEntries: [
                    { name: "value", allowedTypes: ["I", "Q", "M", "D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60"><line x1="0" y1="30" x2="20" y2="30" stroke="gray" stroke-width="2"/><line x1="20" y1="20" x2="20" y2="40" stroke="gray" stroke-width="2"/><line x1="40" y1="20" x2="40" y2="40" stroke="gray" stroke-width="2"/><line x1="40" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2"/></svg>`,
                pins: [{ left: true, right: true }]
            },
            "NC": { // Normally Closed contact
                cells: 1,
                dataEntries: [
                    { name: "value", allowedTypes: ["I", "Q", "M", "D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60"><line x1="0" y1="30" x2="20" y2="30" stroke="gray" stroke-width="2"/><line x1="20" y1="20" x2="20" y2="40" stroke="gray" stroke-width="2"/><line x1="40" y1="20" x2="40" y2="40" stroke="gray" stroke-width="2"/><line x1="40" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2"/><line x1="20" y1="40" x2="40" y2="20" stroke="gray" stroke-width="2"/></svg>`,
                pins: [{ left: true, right: true }]
            },
            "RE": { // Rising Edge contact
                cells: 1,
                dataEntries: [
                    { name: "value", allowedTypes: ["I", "Q", "M", "D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60"><line x1="0" y1="30" x2="20" y2="30" stroke="gray" stroke-width="2"/><line x1="20" y1="20" x2="20" y2="40" stroke="gray" stroke-width="2"/><line x1="40" y1="20" x2="40" y2="40" stroke="gray" stroke-width="2"/><line x1="40" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2"/><text x="30" y="35" font-size="12" text-anchor="middle" fill="gray">P</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "FE": { // Falling Edge contact
                cells: 1,
                dataEntries: [
                    { name: "value", allowedTypes: ["I", "Q", "M", "D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60"><line x1="0" y1="30" x2="20" y2="30" stroke="gray" stroke-width="2"/><line x1="20" y1="20" x2="20" y2="40" stroke="gray" stroke-width="2"/><line x1="40" y1="20" x2="40" y2="40" stroke="gray" stroke-width="2"/><line x1="40" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2"/><text x="30" y="35" font-size="12" text-anchor="middle" fill="gray">N</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "COIL": { // Standard coil
                cells: 1,
                dataEntries: [
                    { name: "value", allowedTypes: ["M", "Q"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg3" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs3" /> <line x1="0" y1="30" x2="20.790773" y2="30" stroke="#808080" stroke-width="2" id="line1" /> <text x="20" y="35" font-size="16" fill="gray" id="text1">(</text> <text x="35" y="35" font-size="16" fill="gray" id="text3">)</text> <line x1="38.945633" y1="30" x2="60" y2="30" stroke="#808080" stroke-width="2" id="line3" /></svg>`,
                pins: [{ left: true, right: true }]
            },
            "COILL": { // Latch (Set) coil
                cells: 1,
                dataEntries: [
                    { name: "value", allowedTypes: ["M", "Q"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg3" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs3" /> <line x1="0" y1="30" x2="20.790773" y2="30" stroke="#808080" stroke-width="2" id="line1" /> <text x="20" y="35" font-size="16" fill="gray" id="text1">(</text> <text x="30.077431" y="34.868206" font-size="12px" text-anchor="middle" fill="#808080" id="text2">L</text> <text x="35" y="35" font-size="16" fill="gray" id="text3">)</text> <line x1="38.945633" y1="30" x2="60" y2="30" stroke="#808080" stroke-width="2" id="line3" /></svg>`,
                pins: [{ left: true, right: true }]
            },
            "COILU": { // Unlatch (Reset) coil
                cells: 1,
                dataEntries: [
                    { name: "value", allowedTypes: ["M", "Q"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg3" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs3" /> <line x1="0" y1="30" x2="20.790773" y2="30" stroke="#808080" stroke-width="2" id="line1" /> <text x="20" y="35" font-size="16" fill="gray" id="text1">(</text> <text x="30.077431" y="34.868206" font-size="12px" text-anchor="middle" fill="#808080" id="text2">U</text> <text x="35" y="35" font-size="16" fill="gray" id="text3">)</text> <line x1="38.945633" y1="30" x2="60" y2="30" stroke="#808080" stroke-width="2" id="line3" /></svg>`,
                pins: [{ left: true, right: true }]
            },
            "TON": { // On-Delay Timer
                cells: 2,
                dataEntries: [
                    { name: "timer", allowedTypes: ["T"] },
                    { name: "basetime", allowedTypes: ["MS", "10MS", "100MS", "SEC", "MIN"] }
                ],
                svg: `<svg viewBox="0 0 60 120" version="1.1" id="svg4" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs4" /> <rect x="10" y="10" width="40" height="100" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <text x="13" y="40" font-size="10px" fill="#808080" id="text2">IN</text> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line2" /> <text x="34.472816" y="39.736408" font-size="10px" fill="#808080" id="text3">Q0</text> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line3" /> <text x="35.395386" y="99.868202" font-size="10px" fill="#808080" id="text4">Q1</text> <line x1="50" y1="90.527176" x2="60" y2="90.527176" stroke="#808080" stroke-width="2" id="line4" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.658978" y="10.868204" /> <text x="30.049425" y="23.522242" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">TON</text></svg>`,
                pins: [
                    { left: true, right: true },
                    { left: false, right: true }
                ]
            },
            "TOF": { // Off-Delay Timer
                cells: 2,
                dataEntries: [
                    { name: "timer", allowedTypes: ["T"] },
                    { name: "basetime", allowedTypes: ["MS", "10MS", "100MS", "SEC", "MIN"] }
                ],
                svg: `<svg viewBox="0 0 60 120" version="1.1" id="svg4" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs4" /> <rect x="10" y="10" width="40" height="100" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <text x="13" y="40" font-size="10px" fill="#808080" id="text2">IN</text> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line2" /> <text x="34.472816" y="39.736408" font-size="10px" fill="#808080" id="text3">Q0</text> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line3" /> <text x="35.395386" y="99.868202" font-size="10px" fill="#808080" id="text4">Q1</text> <line x1="50" y1="90.527176" x2="60" y2="90.527176" stroke="#808080" stroke-width="2" id="line4" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.658978" y="10.868204" /> <text x="30.049425" y="23.522242" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">TOF</text></svg>`,
                pins: [
                    { left: true, right: true },
                    { left: false, right: true }
                ]
            },
            "TP": { // Pulse Timer
                cells: 2,
                dataEntries: [
                    { name: "timer", allowedTypes: ["T"] },
                    { name: "basetime", allowedTypes: ["MS", "10MS", "100MS", "SEC", "MIN"] }
                ],
                svg: `<svg viewBox="0 0 60 120" version="1.1" id="svg4" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs4" /> <rect x="10" y="10" width="40" height="100" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <text x="13" y="40" font-size="10px" fill="#808080" id="text2">IN</text> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line2" /> <text x="34.472816" y="39.736408" font-size="10px" fill="#808080" id="text3">Q0</text> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line3" /> <text x="35.395386" y="99.868202" font-size="10px" fill="#808080" id="text4">Q1</text> <line x1="50" y1="90.527176" x2="60" y2="90.527176" stroke="#808080" stroke-width="2" id="line4" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.658978" y="10.868204" /> <text x="30.049425" y="23.522242" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">TP</text></svg>`,
                pins: [
                    { left: true, right: true },
                    { left: false, right: true }
                ]
            },
            "CTU": { // Up Counter
                cells: 2,
                dataEntries: [
                    { name: "counter", allowedTypes: ["C"] },
                    { name: "preset value", allowedTypes: ["NONE"] }
                ],
                svg: `<svg viewBox="0 0 60 120" version="1.1" id="svg5" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs5" /> <rect x="10" y="10" width="40" height="100" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <text x="13" y="40" font-size="10px" fill="#808080" id="text2">CU</text> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line2" /> <text x="34.341022" y="39.868206" font-size="10px" fill="#808080" id="text4">Q0</text> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line4" /> <text x="35" y="100" font-size="10" fill="gray" id="text5">Q1</text> <line x1="50" y1="90.263588" x2="60" y2="90.263588" stroke="#808080" stroke-width="2" id="line5" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.672158" y="10.876442" /> <text x="30.062603" y="23.530479" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">CTU</text></svg>`,
                pins: [
                    { left: true, right: true },
                    { left: false, right: true }
                ]
            },
            "CTD": { // Down Counter
                cells: 2,
                dataEntries: [
                    { name: "counter", allowedTypes: ["C"] },
                    { name: "preset value", allowedTypes: ["NONE"] }
                ],
                svg: `<svg viewBox="0 0 60 120" version="1.1" id="svg5" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs5" /> <rect x="10" y="10" width="40" height="100" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <text x="13" y="40" font-size="10px" fill="#808080" id="text2">CU</text> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line2" /> <text x="34.341022" y="39.868206" font-size="10px" fill="#808080" id="text4">Q0</text> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line4" /> <text x="35" y="100" font-size="10" fill="gray" id="text5">Q1</text> <line x1="50" y1="90.263588" x2="60" y2="90.263588" stroke="#808080" stroke-width="2" id="line5" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.672158" y="10.876442" /> <text x="30.062603" y="23.530479" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">CTD</text></svg>`,
                pins: [
                    { left: true, right: true },
                    { left: false, right: true }
                ]
            },
            "MOV": { // Move operation
                cells: 1,
                dataEntries: [
                    { name: "from", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "to", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">MOV</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "SUB": { // Subtraction operation
                cells: 3,
                dataEntries: [
                    { name: "value1", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "value2", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "result", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 180" version="1.1" id="svg5" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs5" /> <rect x="10" y="10" width="40" height="160" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <text x="13.023065" y="40" font-size="10px" fill="#808080" id="text2">IN</text> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line2" /> <text x="33.790775" y="40" font-size="10px" fill="#808080" id="text3">Q0</text> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line3" /> <text x="35" y="100" font-size="10" fill="gray" id="text4">Q1</text> <line x1="50.197693" y1="90.593079" x2="60.197693" y2="90.593079" stroke="#808080" stroke-width="2" id="line4" /> <text x="35" y="160" font-size="10" fill="gray" id="text5">Q2</text> <line x1="50" y1="151.18616" x2="60" y2="151.18616" stroke="#808080" stroke-width="2" id="line5" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.403625" y="10.835256" /> <text x="29.794073" y="23.489292" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000"><tspan style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-family:sans-serif;-inkscape-font-specification:sans-serif" id="tspan5">SUB</tspan></text></svg>`,
                pins: [
                    { left: true, right: true },
                    { left: false, right: true },
                    { left: false, right: true }
                ]
            },
            "ADD": { // Addition operation
                cells: 1,
                dataEntries: [
                    { name: "value1", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "value2", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "result", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">ADD</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "MUL": { // Multiplication operation
                cells: 1,
                dataEntries: [
                    { name: "value1", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "value2", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "result", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">MUL</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "DIV": { // Division operation
                cells: 2,
                dataEntries: [
                    { name: "value1", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "value2", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "result", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 120" version="1.1" id="svg4" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs4" /> <rect x="10" y="10" width="40" height="100" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <text x="13" y="40" font-size="10px" fill="#808080" id="text2">IN</text> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line2" /> <text x="34.472816" y="40" font-size="10px" fill="#808080" id="text3">Q0</text> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line3" /> <text x="35" y="100" font-size="10" fill="gray" id="text4">Q1</text> <line x1="50" y1="90.527176" x2="60" y2="90.527176" stroke="#808080" stroke-width="2" id="line4" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.851729" y="10.906096" /> <text x="30.242176" y="23.560133" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">DIV</text></svg>`,
                pins: [
                    { left: true, right: true },
                    { left: false, right: true }
                ]
            },
            "MOD": { // Modulus operation
                cells: 1,
                dataEntries: [
                    { name: "value1", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "value2", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "result", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">MOD</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "SHL": { // Shift Left operation
                cells: 1,
                dataEntries: [
                    { name: "value", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "result", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">SHL</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "SHR": { // Shift Right operation
                cells: 1,
                dataEntries: [
                    { name: "value", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "result", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">SHR</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "ROL": { // Rotate Left operation
                cells: 1,
                dataEntries: [
                    { name: "value", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "result", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">ROL</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "ROR": { // Rotate Right operation
                cells: 1,
                dataEntries: [
                    { name: "value", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "result", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">ROR</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "AND": { // Logical AND operation
                cells: 1,
                dataEntries: [
                    { name: "value1", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "value2", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "result", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">AND</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "OR": { // Logical OR operation
                cells: 1,
                dataEntries: [
                    { name: "value1", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "value2", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "result", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">OR</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "XOR": { // Logical XOR operation
                cells: 1,
                dataEntries: [
                    { name: "value1", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "value2", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "result", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">XOR</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "NOT": { // Logical NOT operation
                cells: 1,
                dataEntries: [
                    { name: "value", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "result", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">NOT</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "EQ": { // Equal comparison
                cells: 1,
                dataEntries: [
                    { name: "value1", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "value2", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">EQ</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "GT": { // Greater Than comparison
                cells: 1,
                dataEntries: [
                    { name: "value1", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "value2", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">GT</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "GE": { // Greater or Equal comparison
                cells: 1,
                dataEntries: [
                    { name: "value1", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "value2", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">GE</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "LT": { // Less Than comparison
                cells: 1,
                dataEntries: [
                    { name: "value1", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "value2", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">LT</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "LE": { // Less or Equal comparison
                cells: 1,
                dataEntries: [
                    { name: "value1", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "value2", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">LE</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "NE": { // Not Equal comparison
                cells: 1,
                dataEntries: [
                    { name: "value1", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "value2", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">NE</text></svg>`,
                pins: [{ left: true, right: true }]
            },
            "TMOV": { // Table Move operation
                cells: 1,
                dataEntries: [
                    { name: "value1", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "value2", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] },
                    { name: "to", allowedTypes: ["D", "T", "C", "IW", "K", "QW"] }
                ],
                svg: `<svg viewBox="0 0 60 60" version="1.1" id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <line x1="0" y1="30" x2="10" y2="30" stroke="gray" stroke-width="2" id="line1" /> <rect x="10" y="10" width="40" height="40" fill="none" stroke="gray" stroke-width="2" id="rect1" /> <line x1="50" y1="30" x2="60" y2="30" stroke="gray" stroke-width="2" id="line2" /> <rect style="opacity:0.363002;fill:#999999" id="rect4" width="38.484348" height="17.133444" x="10.822076" y="11.023065" /> <text x="30.212521" y="23.677101" font-size="12px" text-anchor="middle" fill="gray" id="text1" style="fill:#000000">TMOV</text></svg>`,
                pins: [{ left: true, right: true }]
            }
        };

        // Validates if a string is a valid unsigned 32-bit integer
        function isValidUInt32(str) {
            const num = parseInt(str, 10);
            return /^\d+$/.test(str) && !isNaN(num) && num >= 0 && num <= 4294967295;
        }

        // Validates Q or I type values (format "m.p" where m and p are 0-255)
        function isValidQorI(value) {
            const parts = value.split('.');
            if (parts.length !== 2) return false;
            return parts.every(part => {
                const num = parseInt(part, 10);
                return /^\d+$/.test(part) && !isNaN(num) && num >= 0 && num <= 255;
            });
        }

        // Validates real number format (e.g., "1.23", "-4.5e2")
        function isValidReal(value) {
            return /^[-+]?(\d+\.?\d*|\.\d+)([eE][-+]?\d+)?$/.test(value);
        }

        // Validates string values (accepts any string for CSTR)
        function isValidCSTR(value) {
            return true;
        }

        // Validates input value based on its data type
        function validateValue(type, value) {
            switch (type) {
                case "NONE":
                case "M":
                case "Cd":
                case "Cr":
                case "Td":
                case "Tr":
                case "IW":
                case "QW":
                case "C":
                case "T":
                case "D":
                case "MS":
                case "10MS":
                case "100MS":
                case "SEC":
                case "MIN":
                case "K":
                    return isValidUInt32(value);
                case "Q":
                case "I":
                    return isValidQorI(value);
                case "CSTR":
                    return isValidCSTR(value);
                case "REAL":
                    return isValidReal(value);
                default:
                    return false;
            }
        }

        // Returns the default value based on data type
        function getDefaultValue(type) {
            switch (type) {
                case "Q":
                case "I":
                    return "0.0";
                case "CSTR":
                    return "";
                case "REAL":
                    return "0.0";
                default:
                    return "0";
            }
        }

        // Constants defining maximum limits for the editor
        const MAX_ROWS = 100;      // Maximum rows per network
        const MAX_COLS = 100;      // Maximum columns per network
        const MAX_NETWORKS = 10;   // Maximum number of networks

        // List of coil-type symbols
        const coilSymbols = ["COIL", "COILL", "COILU"];

        // Global variables for editor state
        let networks = [];         // Array of all networks
        let networkCounter = 0;    // Counter for assigning network IDs
        let history = [];          // History stack for undo/redo
        let historyIndex = -1;     // Current position in history
        let currentMenu = null;    // Tracks the currently open menu
        let sameDimensionsFlag = false; // Flag to enforce same dimensions across networks

        // Class representing a single ladder logic network
        class Network {
            constructor(rows, cols, id = null) {
                this.id = id !== null ? id : networkCounter++; // Assigns unique ID
                this.rows = rows;    // Number of rows in the grid
                this.cols = cols;    // Number of columns in the grid
                // Initializes grid with NOP symbols
                this.networkData = Array(rows).fill().map(() => Array(cols).fill().map(() => ({
                    symbol: "NOP",
                    bar: false,      // Indicates vertical bar presence
                    data: []         // Data entries for the symbol
                })));
                this.createNetworkElement(); // Creates HTML elements for the network
            }

            // Creates the DOM elements for the network
            createNetworkElement() {
                const container = document.getElementById('networks-container');
                const wrapper = document.createElement('div');
                wrapper.className = 'network-wrapper';
                wrapper.id = `network-container-${this.id}`;

                const label = document.createElement('div');
                label.className = 'network-label';
                label.textContent = `Network ${this.id}`;

                const controls = document.createElement('div');
                controls.className = 'network-controls';

                const rowsLabel = document.createElement('label');
                rowsLabel.textContent = 'Rows: ';
                const rowsInput = document.createElement('input');
                rowsInput.type = 'number';
                rowsInput.id = `rows-${this.id}`;
                rowsInput.value = this.rows;
                rowsInput.min = '1';
                rowsLabel.appendChild(rowsInput);

                const colsLabel = document.createElement('label');
                colsLabel.textContent = 'Cols: ';
                const colsInput = document.createElement('input');
                colsInput.type = 'number';
                colsInput.id = `cols-${this.id}`;
                colsInput.value = this.cols;
                colsInput.min = '1';
                colsLabel.appendChild(colsInput);

                const resizeButton = document.createElement('button');
                resizeButton.textContent = 'Resize';
                resizeButton.onclick = () => resizeNetwork(this.id);
                const deleteButton = document.createElement('button');
                deleteButton.className = 'delete-button';
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => deleteOrClearNetwork(this.id);

                controls.appendChild(rowsLabel);
                controls.appendChild(colsLabel);
                controls.appendChild(resizeButton);
                controls.appendChild(deleteButton);

                const table = document.createElement('table');
                table.id = `network-${this.id}`;
                table.className = 'network-table';

                wrapper.appendChild(label);
                wrapper.appendChild(controls);
                wrapper.appendChild(table);
                container.appendChild(wrapper);
            }

            // Clears the network by resetting all cells to NOP
            clear() {
                this.networkData = Array(this.rows).fill().map(() => Array(this.cols).fill().map(() => ({
                    symbol: "NOP",
                    bar: false,
                    data: []
                })));
                this.renderNetwork();
                renderSymbolValues();
            }

            // Resizes the network grid, preserving data where possible
            resize(newRows, newCols) {
                const oldRows = this.rows;
                const oldCols = this.cols;
                let truncateWarning = false;

                for (let i = 0; i < oldRows; i++) {
                    for (let j = 0; j < oldCols; j++) {
                        const cell = this.networkData[i][j];
                        if (cell.symbol !== "NOP" && cell.symbol !== "occupied") {
                            const symbol = symbols[cell.symbol];
                            if (i + symbol.cells > newRows || j >= newCols) {
                                truncateWarning = true;
                            }
                        }
                    }
                }

                if (truncateWarning) {
                    showToast("Warning: Some symbols may be removed due to smaller dimensions.");
                }

                this.rows = newRows;
                this.cols = newCols;

                const newNetworkData = Array(newRows).fill().map(() => Array(newCols).fill().map(() => ({
                    symbol: "NOP",
                    bar: false,
                    data: []
                })));

                for (let i = 0; i < Math.min(oldRows, newRows); i++) {
                    for (let j = 0; j < Math.min(oldCols, newCols); j++) {
                        const cell = this.networkData[i][j];
                        if (cell.symbol !== "NOP" && cell.symbol !== "occupied") {
                            const symbol = symbols[cell.symbol];
                            if (i + symbol.cells <= newRows) {
                                newNetworkData[i][j] = { ...cell };
                                for (let k = 1; k < symbol.cells && i + k < newRows; k++) {
                                    newNetworkData[i + k][j] = {
                                        symbol: "occupied",
                                        bar: false,
                                        data: []
                                    };
                                }
                            }
                        } else {
                            newNetworkData[i][j] = { ...cell };
                        }
                    }
                }

                this.networkData = newNetworkData;
                document.getElementById(`rows-${this.id}`).value = newRows;
                document.getElementById(`cols-${this.id}`).value = newCols;
                this.renderNetwork();
                renderSymbolValues();
            }

            // Renders the network grid in the DOM
            renderNetwork() {
                const network = document.getElementById(`network-${this.id}`);
                const networkContainer = document.getElementById(`network-container-${this.id}`);
                if (!network || !networkContainer) {
                    console.error(`Network ${this.id} or container not found`);
                    return;
                }
                network.innerHTML = '';

                // Remove existing labels and bars
                document.querySelectorAll(`#network-container-${this.id} .row-label, #network-container-${this.id} .col-label, #network-container-${this.id} .vertical-bar`).forEach(el => el.remove());

                // Get CSS variable values for positioning
                const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || 60;
                const labelWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--label-width')) || 40;
                const controlsHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--controls-height')) || 60;

                // Add column labels
                for (let j = 0; j < this.cols; j++) {
                    const colLabel = document.createElement('div');
                    colLabel.className = 'col-label';
                    colLabel.textContent = j;
                    colLabel.style.setProperty('--col-index', j);
                    networkContainer.appendChild(colLabel);
                }

                // Render the grid
                for (let i = 0; i < this.rows; i++) {
                    const tr = document.createElement('tr');
                    const rowLabel = document.createElement('div');
                    rowLabel.className = 'row-label';
                    rowLabel.textContent = i;
                    rowLabel.style.setProperty('--row-index', i);
                    networkContainer.appendChild(rowLabel);

                    for (let j = 0; j < this.cols; j++) {
                        if (this.networkData[i][j].symbol === "occupied") continue;

                        const td = document.createElement('td');
                        td.dataset.row = i;
                        td.dataset.col = j;
                        td.dataset.networkId = this.id;

                        if (this.networkData[i][j].symbol !== "NOP") {
                            const symbol = symbols[this.networkData[i][j].symbol];
                            try {
                                const svgContainer = document.createElement('div');
                                svgContainer.innerHTML = symbol.svg;
                                const svgElement = svgContainer.querySelector('svg');
                                if (svgElement) {
                                    td.rowSpan = symbol.cells;
                                    svgElement.style.width = `${cellSize}px`;
                                    svgElement.style.height = `${cellSize * symbol.cells}px`;
                                    svgElement.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                                    if (symbol.cells > 1) {
                                        svgElement.classList.add('multi-cell-svg');
                                        td.style.position = 'relative';
                                    }
                                    td.appendChild(svgElement);
                                    for (let k = 1; k < symbol.cells && i + k < this.rows; k++) {
                                        this.networkData[i + k][j].symbol = "occupied";
                                    }
                                } else {
                                    td.innerHTML = '<div style="color: red; font-size: 10px;">Invalid Symbol</div>';
                                    console.error(`Failed to parse SVG for symbol ${this.networkData[i][j].symbol}`);
                                }
                            } catch (e) {
                                console.error(`Error rendering symbol ${this.networkData[i][j].symbol}:`, e);
                            }
                        }

                        td.addEventListener('click', showSymbolMenu);
                        td.addEventListener('contextmenu', showDataTypeMenu);
                        tr.appendChild(td);
                    }
                    network.appendChild(tr);
                }

                // Add vertical bars
                for (let i = 1; i < this.rows; i++) {
                    for (let j = 0; j < this.cols - 1; j++) {
                        if (this.networkData[i][j].bar && this.networkData[i][j].symbol !== 'occupied') {
                            try {
                                const barDiv = document.createElement('div');
                                barDiv.className = 'vertical-bar';
                                const barSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                                barSvg.setAttribute('width', '2');
                                barSvg.setAttribute('height', cellSize.toString());
                                barSvg.setAttribute('viewBox', `0 0 2 ${cellSize}`);
                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                line.setAttribute('x1', '1');
                                line.setAttribute('y1', '0');
                                line.setAttribute('x2', '1');
                                line.setAttribute('y2', cellSize.toString());
                                line.setAttribute('stroke', 'gray');
                                line.setAttribute('stroke-width', '2');
                                barSvg.appendChild(line);
                                barDiv.appendChild(barSvg);
                                barDiv.style.left = `${labelWidth + (j + 1) * cellSize}px`;
                                barDiv.style.top = `${controlsHeight + 20 + (i - 1) * cellSize + cellSize / 2}px`;
                                networkContainer.appendChild(barDiv);
                            } catch (e) {
                                console.error(`Error rendering bar at (${i}, ${j}):`, e);
                            }
                        }
                    }
                }
            }
        }

        // Updates the symbol values table with current data
        function renderSymbolValues() {
            const symbolValuesDiv = document.getElementById('symbolValues');
            let html = '<h3>Symbol Values</h3>';
            html += '<table>';
            html += '<tr><th>Network ID</th><th>Row</th><th>Column</th><th>Symbol</th><th>Data</th></tr>';

            let rowIndex = 0;
            networks.forEach(network => {
                for (let i = 0; i < network.rows; i++) {
                    for (let j = 0; j < network.cols; j++) {
                        const cell = network.networkData[i][j];
                        if (cell.symbol !== "NOP" && cell.symbol !== 'occupied' && cell.data.length > 0) {
                            const dataStr = cell.data.map(d => `${d.name}: ${d.type} ${d.value}`).join(', ');
                            html += `<tr class="symbol-row">
                                <td data-label="Network ID" class="network-id">${network.id}</td>
                                <td data-label="Row">${i}</td>
                                <td data-label="Column">${j}</td>
                                <td data-label="Symbol" class="symbol">${cell.symbol}</td>
                                <td data-label="Data" class="data">${dataStr}</td>
                            </tr>`;
                            rowIndex++;
                        }
                    }
                }
            });

            html += '</table>';

            if (rowIndex === 0) {
                html += '<p>No values assigned.</p>';
            }

            symbolValuesDiv.innerHTML = html;
        }

        // Adds a new network to the editor
        function addNetwork() {
            let rows = 8; // Default size
            let cols = 8;
            if (sameDimensionsFlag && networks.length > 0) {
                rows = networks[0].rows; // Enforces same dimensions if flag is set
                cols = networks[0].cols;
            }
            const newNetwork = new Network(rows, cols);
            networks.push(newNetwork);
            newNetwork.renderNetwork();
            renderSymbolValues();
            saveToHistory();
        }

        // Resizes a network based on user input
        function resizeNetwork(id) {
            const rowsInput = document.getElementById(`rows-${id}`);
            const colsInput = document.getElementById(`cols-${id}`);
            const newRows = parseInt(rowsInput.value);
            const newCols = parseInt(colsInput.value);
            if (isNaN(newRows) || isNaN(newCols) || newRows < 1 || newCols < 1) {
                showToast("Rows and columns must be positive numbers.");
                return;
            }
            if (newRows > MAX_ROWS || newCols > MAX_COLS) {
                showToast(`Cannot resize: exceeds maximum limits (rows <= ${MAX_ROWS}, cols <= ${MAX_COLS}).`);
                return;
            }
            if (sameDimensionsFlag) {
                networks.forEach(network => {
                    network.resize(newRows, newCols); // Resizes all networks if flag is set
                });
            } else {
                const network = networks.find(n => n.id === id);
                if (network) {
                    network.resize(newRows, newCols);
                }
            }
            saveToHistory();
        }

        // Deletes a network or clears it if it's the last one
        function deleteOrClearNetwork(id) {
            const network = networks.find(n => n.id === id);
            if (!network) return;

            if (networks.length === 1) {
                network.clear(); // Clears the network if only one remains
                showToast("Network cleared. At least one network must remain.");
                saveToHistory();
            } else {
                const indexToDelete = networks.findIndex(n => n.id === id);
                const containerToRemove = document.getElementById(`network-container-${id}`);
                if (containerToRemove) containerToRemove.remove();
                networks.splice(indexToDelete, 1);
                document.getElementById('networks-container').innerHTML = '';
                networks.forEach((network, newIndex) => {
                    network.id = newIndex; // Reassigns IDs
                    network.createNetworkElement();
                    network.renderNetwork();
                });
                networkCounter = networks.length;
                renderSymbolValues();
                saveToHistory();
            }
        }

        // Closes all open context menus
        function closeAllMenus() {
            document.getElementById('symbolMenu').style.display = 'none';
            document.getElementById('dataTypeMenu').style.display = 'none';
            currentMenu = null;
        }

        // Shows the symbol selection menu on left-click
        function showSymbolMenu(event) {
            event.preventDefault();
            event.stopPropagation();
            closeAllMenus();
            const td = event.currentTarget;
            const row = parseInt(td.dataset.row);
            const col = parseInt(td.dataset.col);
            const networkId = parseInt(td.dataset.networkId);
            const network = networks.find(n => n.id === networkId);
            const menu = document.getElementById('symbolMenu');
            menu.innerHTML = '';

            // Option to add a vertical bar
            if (row > 0 && col < network.cols - 1 && network.networkData[row][col].symbol !== 'occupied' && !network.networkData[row][col].bar) {
                const addBarItem = document.createElement('div');
                addBarItem.className = 'menu-item';
                addBarItem.textContent = 'Add Vertical Bar';
                addBarItem.onclick = () => {
                    addVerticalBar(networkId, row, col);
                    closeAllMenus();
                };
                menu.appendChild(addBarItem);
            }

            // Option to delete a vertical bar
            if (network.networkData[row][col].bar) {
                const deleteBarItem = document.createElement('div');
                deleteBarItem.className = 'menu-item';
                deleteBarItem.textContent = 'Delete Vertical Bar';
                deleteBarItem.onclick = () => {
                    deleteVerticalBar(networkId, row, col);
                    closeAllMenus();
                };
                menu.appendChild(deleteBarItem);
            }

            // Option to delete an existing symbol
            if (network.networkData[row][col].symbol !== "NOP" && network.networkData[row][col].symbol !== 'occupied') {
                const deleteItem = document.createElement('div');
                deleteItem.className = 'menu-item';
                deleteItem.textContent = 'Delete Symbol';
                deleteItem.onclick = () => {
                    placeSymbol(networkId, row, col, 'delete');
                    closeAllMenus();
                };
                menu.appendChild(deleteItem);
            }

            // Options to place new symbols
            if (network.networkData[row][col].symbol === "NOP" || network.networkData[row][col].symbol === "CONN") {
                Object.keys(symbols).filter(name => name !== "NOP").forEach(name => {
                    const item = document.createElement('div');
                    item.className = 'menu-item';
                    item.textContent = name;
                    item.onclick = () => {
                        placeSymbolWithValues(networkId, row, col, name);
                        closeAllMenus();
                    };
                    menu.appendChild(item);
                });
            }

            const rect = td.getBoundingClientRect();
            menu.style.left = `${rect.left + window.scrollX}px`;
            menu.style.top = `${rect.bottom + window.scrollY}px`;
            menu.style.display = 'block';
            currentMenu = menu;
        }

        // Shows the data type menu on right-click with the modification
        function showDataTypeMenu(event) {
            event.preventDefault();
            event.stopPropagation();
            closeAllMenus();
            const td = event.currentTarget;
            const row = parseInt(td.dataset.row);
            const col = parseInt(td.dataset.col);
            const networkId = parseInt(td.dataset.networkId);
            const network = networks.find(n => n.id === networkId);
            const menu = document.getElementById('dataTypeMenu');
            menu.innerHTML = '';

            const cellSymbol = network.networkData[row][col].symbol;
            if (cellSymbol === 'occupied' || !symbols[cellSymbol] || symbols[cellSymbol].dataEntries.length === 0) {
                return;
            }

            const symbol = symbols[cellSymbol];
            const dataEntries = symbol.dataEntries;
            const inputs = [];

            for (let i = 0; i < dataEntries.length; i++) {
                const entry = dataEntries[i];
                const valueDiv = document.createElement('div');
                valueDiv.className = 'value-entry';

                const label = document.createElement('span');
                label.className = 'value-label';
                label.textContent = entry.name + ':';
                valueDiv.appendChild(label);

                const pairDiv = document.createElement('div');
                pairDiv.className = 'value-pair';

                let typeSelect = null;
                if (entry.allowedTypes.length === 1) {
                    if (entry.allowedTypes[0] !== "NONE") {
                        const typeText = document.createElement('span');
                        typeText.textContent = entry.allowedTypes[0];
                        pairDiv.appendChild(typeText);
                    }
                } else {
                    typeSelect = document.createElement('select');
                    entry.allowedTypes.forEach(type => {
                        const option = document.createElement('option');
                        option.value = type;
                        option.textContent = type;
                        if (type === (network.networkData[row][col].data[i]?.type || entry.allowedTypes[0])) option.selected = true;
                        typeSelect.appendChild(option);
                    });
                    pairDiv.appendChild(typeSelect);
                    typeSelect.onchange = function() {
                        const newType = typeSelect.value;
                        input.value = getDefaultValue(newType);
                    };
                }

                const input = document.createElement('input');
                input.type = 'text';
                input.value = network.networkData[row][col].data[i].value;
                pairDiv.appendChild(input);
                valueDiv.appendChild(pairDiv);
                menu.appendChild(valueDiv);

                inputs.push({
                    input: input,
                    typeSelect: typeSelect,
                    dataIndex: i
                });
            }

            const confirmButton = document.createElement('button');
            confirmButton.textContent = 'Confirm';
            confirmButton.onclick = () => {
                let allValid = true;
                const newData = [];
                inputs.forEach(({ input, typeSelect, dataIndex }) => {
                    const type = typeSelect ? typeSelect.value : dataEntries[dataIndex].allowedTypes[0];
                    const value = input.value;
                    if (!validateValue(type, value)) {
                        allValid = false;
                        input.style.border = '1px solid red';
                    } else {
                        input.style.border = '';
                        newData.push({
                            name: dataEntries[dataIndex].name,
                            type: type,
                            value: value
                        });
                    }
                });
                if (allValid) {
                    network.networkData[row][col].data = newData;
                    network.renderNetwork();
                    renderSymbolValues();
                    saveToHistory();
                    closeAllMenus();
                } else {
                    showToast('Some values are invalid. Please correct them.');
                }
            };
            menu.appendChild(confirmButton);

            const rect = td.getBoundingClientRect();
            menu.style.left = `${rect.left + window.scrollX}px`;
            menu.style.top = `${rect.bottom + window.scrollY}px`;
            menu.style.display = 'block';
            currentMenu = menu;
        }

        // Automatically fills a row with CONN symbols if a functional symbol is present
        function autoCompleteRow(network, row) {
            const hasFunctionalSymbol = network.networkData[row].some(cell => cell.symbol !== "NOP" && cell.symbol !== "CONN");
            if (hasFunctionalSymbol) {
                for (let j = 0; j < network.cols; j++) {
                    if (network.networkData[row][j].symbol === "NOP") {
                        network.networkData[row][j].symbol = "CONN";
                        network.networkData[row][j].data = [];
                    }
                }
            }
        }

        // Places a symbol and handles its data entries and connections
        function placeSymbolWithValues(networkId, row, col, symbolName) {
            const network = networks.find(n => n.id === networkId);
            const symbol = symbols[symbolName];
            if (row + symbol.cells > network.rows) {
                showToast("Not enough rows to place this symbol.");
                return;
            }
            let canPlace = true;
            for (let i = 0; i < symbol.cells && row + i < network.rows; i++) {
                if (network.networkData[row + i][col].symbol !== "NOP" && network.networkData[row + i][col].symbol !== "CONN") {
                    canPlace = false;
                    break;
                }
            }
            if (canPlace) {
                const hasBar = network.networkData[row][col].bar;
                for (let i = 0; i < symbol.cells && row + i < network.rows; i++) {
                    network.networkData[row + i][col].symbol = i === 0 ? symbolName : 'occupied';
                    network.networkData[row + i][col].bar = i === 0 ? hasBar : false;
                    if (i === 0) {
                        network.networkData[row + i][col].data = symbol.dataEntries.map(entry => ({
                            name: entry.name,
                            type: entry.allowedTypes[0],
                            value: getDefaultValue(entry.allowedTypes[0])
                        }));
                    } else {
                        network.networkData[row + i][col].data = [];
                    }
                }

                if (symbol.cells === 1) {
                    autoCompleteRow(network, row);
                } else {
                    for (let i = 0; i < symbol.cells && row + i < network.rows; i++) {
                        const r = row + i;
                        const pin = symbol.pins[i];
                        if (pin.left) {
                            for (let j = 0; j < col; j++) {
                                if (network.networkData[r][j].symbol === "NOP") {
                                    network.networkData[r][j].symbol = "CONN";
                                    network.networkData[r][j].data = [];
                                }
                            }
                        } else {
                            let j = col - 1;
                            while (j >= 0) {
                                if (network.networkData[r][j].symbol === "CONN") {
                                    network.networkData[r][j].symbol = "NOP";
                                    network.networkData[r][j].data = [];
                                } else if (network.networkData[r][j].symbol !== "NOP") {
                                    break;
                                }
                                j--;
                            }
                        }
                        if (pin.right) {
                            for (let j = col + 1; j < network.cols; j++) {
                                if (network.networkData[r][j].symbol === "NOP") {
                                    network.networkData[r][j].symbol = "CONN";
                                    network.networkData[r][j].data = [];
                                }
                            }
                        }
                    }
                }

                network.renderNetwork();
                renderSymbolValues();
                saveToHistory();
            } else {
                showToast("Cannot place symbol: space is already occupied.");
            }
        }

        // Places or deletes a symbol at a specific position
        function placeSymbol(networkId, row, col, symbolName) {
            const network = networks.find(n => n.id === networkId);
            if (symbolName === 'delete') {
                if (network.networkData[row][col].symbol !== "NOP" && network.networkData[row][col].symbol !== 'occupied') {
                    const cells = symbols[network.networkData[row][col].symbol].cells;
                    for (let i = 0; i < cells && row + i < network.rows; i++) {
                        network.networkData[row + i][col].symbol = "NOP";
                        network.networkData[row + i][col].bar = i === 0 ? network.networkData[row][col].bar : false;
                        network.networkData[row + i][col].data = [];
                    }
                    network.renderNetwork();
                    renderSymbolValues();
                    saveToHistory();
                }
            }
        }

        // Adds a vertical bar to connect ladder rungs
        function addVerticalBar(networkId, row, col) {
            const network = networks.find(n => n.id === networkId);
            if (row < 1) {
                showToast("Cannot place vertical bar in the top row.");
                return;
            }
            if (col >= network.cols - 1) {
                showToast("Cannot place vertical bar in the last column.");
                return;
            }
            if (network.networkData[row][col].symbol === 'occupied') {
                showToast("Cannot place vertical bar on an occupied cell.");
                return;
            }
            network.networkData[row][col].bar = true;
            network.renderNetwork();
            renderSymbolValues();
            saveToHistory();
        }

        // Deletes a vertical bar
        function deleteVerticalBar(networkId, row, col) {
            const network = networks.find(n => n.id === networkId);
            network.networkData[row][col].bar = false;
            network.renderNetwork();
            renderSymbolValues();
            saveToHistory();
        }

        // Saves networks to server via WebSocket or downloads as JSON file
        function saveNetworks() {
            if (wsStatus !== "disconnected") {
                const data = networks.map(n => ({
                    id: n.id,
                    rows: n.rows,
                    cols: n.cols,
                    networkData: n.networkData
                }));
                ws.send(JSON.stringify({ action: "save", data: data }));
                showToast("Saved to server.");
            } else {
                const data = networks.map(n => ({
                    id: n.id,
                    rows: n.rows,
                    cols: n.cols,
                    networkData: n.networkData
                }));
                const formattedData = JSON.stringify(data, null, 2);
                const blob = new Blob([formattedData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'ladder_networks.json';
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        // Validates network data when loading from external source
        function validateNetworkData(networkData, rows, cols) {
            const validatedData = [];
            for (let i = 0; i < rows; i++) {
                const row = [];
                for (let j = 0; j < cols; j++) {
                    let cell = networkData[i]?.[j];
                    if (typeof cell !== 'object' || cell === null) {
                        cell = { symbol: "NOP", bar: false, data: [] };
                    }
                    if (typeof cell.symbol !== 'string' || !symbols[cell.symbol]) {
                        cell.symbol = "NOP";
                    }
                    cell.bar = !!cell.bar;
                    if (!Array.isArray(cell.data)) {
                        cell.data = [];
                    }
                    if (cell.symbol !== "NOP" && cell.symbol !== "occupied" && symbols[cell.symbol]) {
                        const symbolDef = symbols[cell.symbol];
                        const expectedDataEntries = symbolDef.dataEntries;
                        const newData = [];
                        expectedDataEntries.forEach(entry => {
                            const loadedEntry = cell.data.find(d => d.name === entry.name && typeof d.type === 'string' && typeof d.value === 'string');
                            if (loadedEntry && entry.allowedTypes.includes(loadedEntry.type) && validateValue(loadedEntry.type, loadedEntry.value)) {
                                newData.push({ name: entry.name, type: loadedEntry.type, value: loadedEntry.value });
                            } else {
                                const defaultType = entry.allowedTypes[0];
                                newData.push({ name: entry.name, type: defaultType, value: getDefaultValue(defaultType) });
                            }
                        });
                        cell.data = newData;
                    } else {
                        cell.data = [];
                    }
                    row.push(cell);
                }
                validatedData.push(row);
            }
            return validatedData;
        }

        // Loads networks from a JSON file
        function loadNetworks(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (file.size > 10 * 1024 * 1024) {
                showToast('File is too large to process.');
                return;
            }
            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                try {
                    const data = JSON.parse(text);
                    if (!Array.isArray(data)) {
                        throw new Error('Invalid network data format: not an array');
                    }
                    if (data.length > MAX_NETWORKS) {
                        showToast(`Only the first ${MAX_NETWORKS} networks will be loaded.`);
                        data = data.slice(0, MAX_NETWORKS);
                    }
                    networks = [];
                    document.getElementById('networks-container').innerHTML = '';
                    document.getElementById('symbolValues').innerHTML = '';
                    networkCounter = 0;
                    data.forEach(n => {
                        if (!Number.isInteger(n.rows) || n.rows < 1 || !Number.isInteger(n.cols) || n.cols < 1) {
                            throw new Error('Invalid network dimensions');
                        }
                        if (n.rows > MAX_ROWS || n.cols > MAX_COLS) {
                            throw new Error(`Network exceeds size limits: rows=${n.rows}, cols=${n.cols}`);
                        }
                        const network = new Network(n.rows, n.cols);
                        network.networkData = validateNetworkData(n.networkData, n.rows, n.cols);
                        networks.push(network);
                        network.renderNetwork();
                    });
                    networks.forEach((n, index) => {
                        n.id = index;
                    });
                    renderSymbolValues();
                    saveToHistory();
                } catch (error) {
                    showToast('Error parsing file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // Initiates loading from server or file input
        function initiateLoad() {
            if (wsStatus !== "disconnected") {
                ws.send(JSON.stringify({ action: "load" }));
                showToast("Loading from server...");
            } else {
                document.getElementById('loadFile').click();
            }
        }

        // Displays a temporary notification message
        function showToast(message) {
            const toast = document.createElement('div');
            toast.style.position = 'fixed';
            toast.style.bottom = '20px';
            toast.style.left = '50%';
            toast.style.transform = 'translateX(-50%)';
            toast.style.background = '#333';
            toast.style.color = 'white';
            toast.style.padding = '10px 20px';
            toast.style.borderRadius = '5px';
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // Saves the current state to history for undo/redo
        function saveToHistory() {
            const state = JSON.stringify(networks.map(n => ({
                id: n.id,
                rows: n.rows,
                cols: n.cols,
                networkData: n.networkData.map(row => row.map(cell => ({ ...cell })))
            })));
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1); // Truncates redo stack
            }
            history.push(state);
            historyIndex++;
        }

        // Reverts to the previous state in history
        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreFromHistory();
            }
        }

        // Advances to the next state in history
        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreFromHistory();
            }
        }

        // Restores the editor state from history
        function restoreFromHistory() {
            const state = JSON.parse(history[historyIndex]);
            networks = [];
            document.getElementById('networks-container').innerHTML = '';
            document.getElementById('symbolValues').innerHTML = '';
            state.forEach(n => {
                const network = new Network(n.rows, n.cols, n.id);
                network.networkData = n.networkData;
                networks.push(network);
                network.renderNetwork();
            });
            if (networks.length > 0) {
                const maxId = Math.max(...networks.map(n => n.id));
                networkCounter = maxId + 1;
            } else {
                networkCounter = 0;
            }
            renderSymbolValues();
        }

        // Event listener for clicking symbol values table rows to highlight cells
        document.getElementById('symbolValues').addEventListener('click', function(event) {
            const row = event.target.closest('tr.symbol-row');
            if (row) {
                const cells = row.cells;
                const networkId = parseInt(cells[0].textContent);
                const rowIndex = parseInt(cells[1].textContent);
                const colIndex = parseInt(cells[2].textContent);
                const cell = document.querySelector(`#network-${networkId} td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
                if (cell) {
                    if (cell.classList.contains('blinking')) {
                        cell.classList.remove('blinking');
                        row.classList.remove('blinking');
                    } else {
                        const previousBlinkingCell = document.querySelector('td.blinking');
                        if (previousBlinkingCell) {
                            previousBlinkingCell.classList.remove('blinking');
                        }
                        const previousBlinkingRow = document.querySelector('tr.blinking');
                        if (previousBlinkingRow) {
                            previousBlinkingRow.classList.remove('blinking');
                        }
                        cell.classList.add('blinking');
                        row.classList.add('blinking');
                    }
                }
            }
        });

        // Clears blinking when clicking outside symbol values table
        document.addEventListener('click', function(event) {
            if (!event.target.closest('#symbolValues')) {
                const blinkingCell = document.querySelector('td.blinking');
                if (blinkingCell) {
                    blinkingCell.classList.remove('blinking');
                }
                const blinkingRow = document.querySelector('tr.blinking');
                if (blinkingRow) {
                    blinkingRow.classList.remove('blinking');
                }
            }
        });

        // Closes context menus when clicking outside
        document.addEventListener('click', function(e) {
            if (currentMenu && !currentMenu.contains(e.target)) {
                currentMenu.style.display = 'none';
                currentMenu = null;
            }
        });

        // Initializes the editor with one network on page load
        window.onload = function() {
            addNetwork();
        };

        // WebSocket setup for real-time communication with server
        const ws = new WebSocket("ws://localhost:8080");
        let wsStatus = "disconnected"; // Tracks WebSocket connection state

        // Updates the WebSocket status indicator color
        function updateIndicator() {
            const indicator = document.getElementById('ws-indicator');
            if (wsStatus === "disconnected") {
                indicator.style.backgroundColor = "red";
            } else if (wsStatus === "connected_not_running") {
                indicator.style.backgroundColor = "yellow";
            } else if (wsStatus === "connected_running") {
                indicator.style.backgroundColor = "green";
            }
        }

        // Resets all cells to default state (removes active class)
        function setAllCellsDefault() {
            document.querySelectorAll('td.active').forEach(cell => cell.classList.remove('active'));
        }

        // Applies active states to cells based on WebSocket data
        function applyCellStates(cellStates) {
            setAllCellsDefault();
            cellStates.forEach(cs => {
                if (cs.state === 1) {
                    const cell = document.querySelector(`#network-${cs.networkId} td[data-row="${cs.row}"][data-col="${cs.col}"]`);
                    if (cell) {
                        cell.classList.add('active');
                    }
                }
            });
        }

        // WebSocket connection established
        ws.onopen = function() {
            ws.send(JSON.stringify({ action: "get_flag" })); // Requests sameDimensions flag
            wsStatus = "connected_not_running";
            updateIndicator();
        };

        // Handles incoming WebSocket messages
        ws.onmessage = function(event) {
            const data = JSON.parse(event.data);
            if (data.flag === "sameDimensions") {
                sameDimensionsFlag = data.value; // Sets flag from server
            } else if (data.action === "load_response") {
                const loadedNetworks = data.data;
                networks = [];
                document.getElementById('networks-container').innerHTML = '';
                document.getElementById('symbolValues').innerHTML = '';
                networkCounter = 0;
                loadedNetworks.forEach(n => {
                    const network = new Network(n.rows, n.cols, n.id);
                    network.networkData = validateNetworkData(n.networkData, n.rows, n.cols);
                    networks.push(network);
                    network.renderNetwork();
                });
                networks.forEach((n, index) => {
                    n.id = index;
                });
                renderSymbolValues();
                saveToHistory();
                showToast("Loaded from server.");
            } else if (data.status) {
                if (data.status === "running") {
                    wsStatus = "connected_running";
                    updateIndicator();
                    if (data.cell_states) {
                        applyCellStates(data.cell_states); // Updates cell states during runtime
                    }
                } else if (data.status === "not_running") {
                    wsStatus = "connected_not_running";
                    updateIndicator();
                    setAllCellsDefault();
                }
            }
        };

        // Handles WebSocket connection closure
        ws.onclose = function() {
            wsStatus = "disconnected";
            updateIndicator();
            setAllCellsDefault();
        };

        // Handles WebSocket errors
        ws.onerror = function() {
            wsStatus = "disconnected";
            updateIndicator();
            setAllCellsDefault();
        };
    </script>
</body>
</html>
